<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Content Manager</title>
    <style>
      :root {
        --bg: #f6f7f9;
        --panel: #ffffff;
        --text: #0f172a;
        --muted: #64748b;
        --border: #e2e8f0;
        --accent: #2563eb;
        --accent-weak: rgba(37, 99, 235, 0.12);
        --danger: #ef4444;
        --success: #16a34a;
        --shadow: 0 10px 30px rgba(2, 6, 23, 0.08);
        --radius: 14px;
      }

      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        font-family:
          ui-sans-serif,
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          "Helvetica Neue",
          Arial,
          "Noto Sans",
          "Apple Color Emoji",
          "Segoe UI Emoji";
        background: var(--bg);
        color: var(--text);
        padding: 24px;
      }

      .container {
        max-width: 980px;
        margin: 0 auto;
      }

      header {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: 16px;
        margin-bottom: 18px;
      }
      h1 {
        margin: 0;
        font-size: 20px;
        letter-spacing: -0.01em;
      }
      .subtitle {
        font-size: 13px;
        color: var(--muted);
      }

      .tabs {
        display: inline-flex;
        border: 1px solid var(--border);
        border-radius: 999px;
        background: var(--panel);
        padding: 4px;
        gap: 4px;
      }
      .tab-btn {
        border: 0;
        background: transparent;
        padding: 10px 14px;
        border-radius: 999px;
        font-weight: 600;
        font-size: 13px;
        cursor: pointer;
        color: var(--muted);
        transition:
          background 0.15s,
          color 0.15s;
      }
      .tab-btn.active {
        background: var(--accent-weak);
        color: var(--accent);
      }

      .panel {
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        padding: 18px;
      }

      .section {
        display: none;
      }
      .section.active {
        display: block;
      }

      .grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 14px;
      }
      @media (max-width: 820px) {
        .grid {
          grid-template-columns: 1fr;
        }
      }

      .form-group {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      label {
        font-size: 12px;
        font-weight: 700;
        color: var(--text);
      }
      .hint {
        font-size: 12px;
        color: var(--muted);
      }

      input[type="text"],
      input[type="date"],
      input[type="number"],
      textarea,
      select {
        width: 100%;
        padding: 10px 12px;
        border: 1px solid var(--border);
        border-radius: 10px;
        font: inherit;
        font-size: 14px;
        background: #fff;
        outline: none;
        transition:
          border-color 0.15s,
          box-shadow 0.15s;
      }
      textarea {
        min-height: 160px;
        resize: vertical;
      }
      input:focus,
      textarea:focus,
      select:focus {
        border-color: var(--accent);
        box-shadow: 0 0 0 4px var(--accent-weak);
      }

      .status {
        display: none;
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid var(--border);
        margin-bottom: 14px;
        font-size: 13px;
      }
      .status.show {
        display: block;
      }
      .status.success {
        border-color: rgba(22, 163, 74, 0.25);
        background: rgba(22, 163, 74, 0.08);
        color: var(--success);
      }
      .status.error {
        border-color: rgba(239, 68, 68, 0.25);
        background: rgba(239, 68, 68, 0.08);
        color: var(--danger);
      }

      .row {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      .btn {
        border: 1px solid var(--border);
        background: #fff;
        color: var(--text);
        padding: 10px 12px;
        border-radius: 12px;
        cursor: pointer;
        font-weight: 700;
        font-size: 13px;
        transition:
          transform 0.03s,
          background 0.15s,
          border-color 0.15s;
      }
      .btn:active {
        transform: translateY(1px);
      }
      .btn.primary {
        background: var(--accent);
        border-color: var(--accent);
        color: #fff;
      }
      .btn.primary:hover {
        filter: brightness(0.98);
      }
      .btn.ghost:hover {
        background: #f1f5f9;
      }

      .two-col {
        display: grid;
        grid-template-columns: 1fr;
        gap: 14px;
        margin-top: 14px;
      }

      .divider {
        height: 1px;
        background: var(--border);
        margin: 14px 0;
      }

      /* Categories */
      .category-list {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
        gap: 8px;
      }
      .category-item {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 10px;
        border: 1px solid var(--border);
        border-radius: 12px;
        background: #fff;
      }
      .category-item input {
        width: 16px;
        height: 16px;
      }
      .category-item label {
        margin: 0;
        font-size: 13px;
        font-weight: 600;
        color: var(--text);
      }

      /* File preview */
      .file-name {
        font-size: 12px;
        color: var(--muted);
        margin-top: 6px;
      }
      .image-preview {
        max-width: 100%;
        max-height: 280px;
        margin-top: 10px;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: #fff;
      }

      /* Block editor */
      .block-editor {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .block {
        display: grid;
        grid-template-columns: 46px 1fr;
        gap: 10px;
        align-items: start;
      }
      .block-type-btn {
        border: 1px solid var(--border);
        background: #fff;
        border-radius: 12px;
        padding: 10px 0;
        font-weight: 800;
        font-size: 12px;
        color: var(--muted);
        cursor: pointer;
      }
      .block-type-btn:hover {
        background: #f8fafc;
      }
      .block-input {
        width: 100%;
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 10px 12px;
        font: inherit;
        font-size: 14px;
        outline: none;
        transition:
          border-color 0.15s,
          box-shadow 0.15s;
      }
      .block-input:focus {
        border-color: var(--accent);
        box-shadow: 0 0 0 4px var(--accent-weak);
      }

      .slash-menu {
        position: absolute;
        background: white;
        border: 1px solid var(--border);
        border-radius: 14px;
        box-shadow: var(--shadow);
        z-index: 9999;
        overflow: hidden;
        min-width: 260px;
      }
      .slash-menu-item {
        padding: 10px 12px;
        cursor: pointer;
        font-size: 13px;
        border-bottom: 1px solid #f1f5f9;
        outline: none;
      }
      .slash-menu-item:last-child {
        border-bottom: 0;
      }
      .slash-menu-item:hover,
      .slash-menu-item.selected {
        background: #f8fafc;
      }
      .slash-menu-item strong {
        color: var(--accent);
        font-weight: 800;
        margin-right: 6px;
      }
      .slash-menu-item small {
        color: var(--muted);
        display: block;
        font-size: 12px;
        margin-top: 2px;
      }

      .page-type {
        display: flex;
        gap: 14px;
        padding: 10px 12px;
        border: 1px solid var(--border);
        border-radius: 12px;
        background: #fff;
      }
      .page-type label {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        font-weight: 700;
        font-size: 13px;
        color: var(--text);
        cursor: pointer;
        margin: 0;
      }
    </style>
  </head>

  <body>
    <div class="container">
      <header>
        <div>
          <h1>Content Manager</h1>
          <div class="subtitle">Articles + Pages (minimal admin UI)</div>
        </div>
        <div class="tabs" role="tablist" aria-label="Content type">
          <button
            class="tab-btn active"
            onclick="switchTab(event, 'article')"
            type="button"
          >
            Article
          </button>
          <button
            class="tab-btn"
            onclick="switchTab(event, 'page')"
            type="button"
          >
            Page
          </button>
        </div>
      </header>

      <!-- ARTICLE SECTION -->
      <section id="article" class="section active">
        <div class="panel">
          <div id="articleStatus" class="status"></div>

          <div class="grid">
            <div class="form-group">
              <label>Edit Existing Article</label>
              <select id="articleSelect" onchange="loadArticle()">
                <option value="">-- Create New --</option>
              </select>
              <div class="hint">Pick one to load it into the editor.</div>
            </div>

            <div class="form-group">
              <label>Date *</label>
              <input type="date" id="articleDate" />
              <div class="hint">Auto-fills to today for new articles.</div>
            </div>

            <div class="form-group">
              <label>Title *</label>
              <input
                type="text"
                id="articleTitle"
                placeholder="Article title"
              />
            </div>

            <div class="form-group">
              <label>Slug (URL) *</label>
              <input
                type="text"
                id="articleSlug"
                placeholder="article-url-slug"
              />
              <div class="hint">Tip: use lowercase + dashes.</div>
            </div>
          </div>

          <div class="divider"></div>

          <div class="grid">
            <div class="form-group">
              <label>Cover Image *</label>
              <input type="file" id="coverImage" accept="image/*" />
              <img
                id="coverPreview"
                class="image-preview"
                style="display: none"
              />
              <div id="coverFileName" class="file-name"></div>
            </div>

            <div class="form-group">
              <label>Categories *</label>
              <div id="categoriesList" class="category-list"></div>
              <div class="hint">Must pick at least 1.</div>
            </div>
          </div>

          <div class="divider"></div>

          <div class="form-group">
            <label>Index this article</label>
            <input type="checkbox" id="articleIndexed" checked />
            <div class="hint">Uncheck to exclude from search indexing</div>
          </div>

          <div class="divider"></div>

          <div class="two-col">
            <div class="form-group">
              <label>Content *</label>
              <div class="hint">
                Enter adds a new block for headings. Ctrl/Cmd+Enter adds a new
                block for paragraphs. Type ‚Äú/‚Äù at the start of an empty block to
                choose a type.
              </div>
              <div id="articleBlockEditor" class="block-editor"></div>
            </div>

            <div class="row">
              <button
                class="btn primary"
                onclick="publishArticle()"
                type="button"
              >
                Publish
              </button>
              <button
                class="btn"
                id="deleteArticleBtn"
                onclick="deleteArticle()"
                type="button"
                style="background: var(--danger); color: white; display: none"
              >
                Delete
              </button>
              <button class="btn ghost" onclick="resetArticle()" type="button">
                Reset
              </button>
            </div>
          </div>
        </div>
      </section>

      <!-- PAGE SECTION -->
      <section id="page" class="section">
        <div class="panel">
          <div id="pageStatus" class="status"></div>

          <div class="grid">
            <div class="form-group">
              <label>Edit Existing Page</label>
              <select id="pageSelect" onchange="loadPage()">
                <option value="">-- Create New --</option>
              </select>
            </div>

            <div class="form-group">
              <label>Menu Order</label>
              <input type="number" id="pageOrder" placeholder="0" />
              <div class="hint">Auto-assign if empty, lower shows earlier.</div>
            </div>

            <div class="form-group">
              <label>Title *</label>
              <input type="text" id="pageTitle" placeholder="Page title" />
            </div>

            <div class="form-group">
              <label>Slug (URL) *</label>
              <input type="text" id="pageSlug" placeholder="page-url-slug" />
            </div>
          </div>

          <div class="divider"></div>

          <div class="form-group">
            <label>Page Type *</label>
            <div class="page-type">
              <label>
                <input
                  type="radio"
                  name="pageType"
                  value="text"
                  checked
                  onchange="togglePageType()"
                />
                Written Content
              </label>
              <label>
                <input
                  type="radio"
                  name="pageType"
                  value="pdf"
                  onchange="togglePageType()"
                />
                PDF File
              </label>
            </div>
          </div>

          <div id="textPageFields">
            <div class="form-group">
              <label>Content *</label>
              <textarea
                id="pageContent"
                placeholder="Write your page content here..."
              ></textarea>
            </div>
          </div>

          <div id="pdfPageFields" style="display: none">
            <div class="form-group">
              <label>PDF File *</label>
              <input type="file" id="pdfFile" accept=".pdf" />
              <div id="pdfFileName" class="file-name"></div>
            </div>
          </div>

          <div class="row">
            <button class="btn primary" onclick="publishPage()" type="button">
              Publish
            </button>
            <button
              class="btn"
              id="deletePageBtn"
              onclick="deletePage()"
              type="button"
              style="background: var(--danger); color: white; display: none"
            >
              Delete
            </button>
            <button class="btn ghost" onclick="resetPage()" type="button">
              Reset
            </button>
          </div>
        </div>
      </section>
    </div>

    <script>
      const API_URL =
        localStorage.getItem("apiUrl") || "http://localhost:3000/api";

      let selectedCategories = [];
      let allCategories = [];
      let currentArticleId = null;
      let currentPageId = null;
      let selectedCoverImage = null;
      let selectedPdfFile = null;

      // Block types for article editor
      const BLOCK_TYPES = {
        paragraph: { label: "¬∂", name: "Paragraph", desc: "Plain text" },
        heading1: { label: "H1", name: "Heading 1", desc: "Large heading" },
        heading2: { label: "H2", name: "Heading 2", desc: "Medium heading" },
        heading3: { label: "H3", name: "Heading 3", desc: "Small heading" },
        quote: { label: "‚ùù", name: "Quote", desc: "Quoted text" },
        list: { label: "‚Ä¢", name: "List Item", desc: "Bulleted item" },
        code: { label: "```", name: "Code", desc: "Code snippet" },
        pdf: { label: "üìÑ", name: "PDF", desc: "PDF file" },
      };

      document.addEventListener("DOMContentLoaded", () => {
        setTodaysDate();
        loadCategories();
        loadExistingArticles();
        loadExistingPages();
        setupImageUpload();
        setupPdfUpload();
        initializeBlockEditor();
        setupAutoPopulate();
      });

      // ===== Tabs =====
      function switchTab(e, tab) {
        document
          .querySelectorAll(".section")
          .forEach((s) => s.classList.remove("active"));
        document
          .querySelectorAll(".tab-btn")
          .forEach((b) => b.classList.remove("active"));
        document.getElementById(tab).classList.add("active");
        e.currentTarget.classList.add("active");

        // reset statuses when switching
        document.getElementById("articleStatus").className = "status";
        document.getElementById("pageStatus").className = "status";

        if (tab === "article") resetArticle();
        else resetPage();
      }

      function showStatus(elementId, message, type) {
        const el = document.getElementById(elementId);
        el.textContent = message;
        el.className = `status show ${type}`;
        if (type === "success") {
          setTimeout(() => {
            el.className = "status";
          }, 2500);
        }
      }

      // ===== BLOCK EDITOR (FIXED) =====
      function initializeBlockEditor() {
        const editor = document.getElementById("articleBlockEditor");
        editor.innerHTML = "";
        addNewBlock(editor, "paragraph");
      }

      function isMultilineType(type) {
        return (
          type === "paragraph" ||
          type === "quote" ||
          type === "list" ||
          type === "code"
        );
      }

      function isFileType(type) {
        return type === "pdf";
      }

      function focusLastBlockInput(editor) {
        const inputs = editor.querySelectorAll(".block-input");
        inputs[inputs.length - 1]?.focus();
      }

      function attachBlockInputHandlers(input, editor, block) {
        input.addEventListener("keydown", (e) => {
          const type = block.dataset.blockType;
          const multiline = isMultilineType(type);

          // Create next block on Enter for headings (single-line)
          if (e.key === "Enter" && !multiline) {
            e.preventDefault();
            addNewBlock(editor, "paragraph");
            focusLastBlockInput(editor);
            return;
          }

          // Ctrl/Cmd+Enter for multiline blocks
          if (e.key === "Enter" && multiline && (e.ctrlKey || e.metaKey)) {
            e.preventDefault();
            addNewBlock(editor, "paragraph");
            focusLastBlockInput(editor);
            return;
          }

          // "/" at start of empty block opens menu
          if (
            e.key === "/" &&
            input.value === "" &&
            input.selectionStart === 0
          ) {
            e.preventDefault();
            showBlockTypeMenu(block);
            return;
          }
        });
      }

      function addNewBlock(editor, type = "paragraph") {
        const block = document.createElement("div");
        block.className = "block";
        const blockId = `block-${Date.now()}-${Math.random().toString(16).slice(2)}`;
        block.dataset.blockId = blockId;
        block.dataset.blockType = type;

        const typeBtn = document.createElement("button");
        typeBtn.className = "block-type-btn";
        typeBtn.textContent = BLOCK_TYPES[type].label;
        typeBtn.type = "button";
        typeBtn.onclick = (e) => {
          e.preventDefault();
          showBlockTypeMenu(block);
        };

        let input;
        if (isFileType(type)) {
          input = document.createElement("input");
          input.type = "file";
          input.accept = ".pdf";
          input.className = "block-input";
          input.placeholder = `Select ${BLOCK_TYPES[type].name.toLowerCase()}...`;
          input.dataset.blockInput = blockId;
        } else {
          const multiline = isMultilineType(type);
          input = document.createElement(multiline ? "textarea" : "input");
          input.className = "block-input";
          if (!multiline) input.type = "text";
          input.placeholder = `Enter ${BLOCK_TYPES[type].name.toLowerCase()}...`;
          input.dataset.blockInput = blockId;

          attachBlockInputHandlers(input, editor, block);
        }

        block.appendChild(typeBtn);
        block.appendChild(input);
        editor.appendChild(block);

        return block;
      }

      let activeMenuCleanup = null;

      function closeBlockTypeMenu() {
        const menu = document.querySelector(".slash-menu");
        if (menu) menu.remove();
        if (activeMenuCleanup) {
          activeMenuCleanup();
          activeMenuCleanup = null;
        }
      }

      function showBlockTypeMenu(block) {
        closeBlockTypeMenu();

        const menu = document.createElement("div");
        menu.className = "slash-menu";

        const rect = block.getBoundingClientRect();
        // position relative to viewport + scroll
        menu.style.top = rect.top + window.scrollY + "px";
        menu.style.left = rect.left + window.scrollX + 60 + "px";

        let selectedIndex = 0;
        const entries = Object.entries(BLOCK_TYPES);

        entries.forEach(([key, value], idx) => {
          const item = document.createElement("div");
          item.className = "slash-menu-item";
          item.tabIndex = 0;
          item.innerHTML = `<strong>${value.label}</strong>${value.name}<small>${value.desc}</small>`;
          item.dataset.blockType = key;

          if (idx === 0) item.classList.add("selected");

          item.onclick = () => {
            changeBlockType(block, key);
            closeBlockTypeMenu();
            block.querySelector(".block-input")?.focus();
          };

          menu.appendChild(item);
        });

        document.body.appendChild(menu);

        const handleKeydown = (e) => {
          const items = menu.querySelectorAll(".slash-menu-item");
          if (!items.length) return;

          if (e.key === "ArrowDown") {
            e.preventDefault();
            selectedIndex = (selectedIndex + 1) % items.length;
            items.forEach((i) => i.classList.remove("selected"));
            items[selectedIndex].classList.add("selected");
            items[selectedIndex].focus();
          } else if (e.key === "ArrowUp") {
            e.preventDefault();
            selectedIndex = (selectedIndex - 1 + items.length) % items.length;
            items.forEach((i) => i.classList.remove("selected"));
            items[selectedIndex].classList.add("selected");
            items[selectedIndex].focus();
          } else if (e.key === "Enter") {
            e.preventDefault();
            const type = items[selectedIndex].dataset.blockType;
            changeBlockType(block, type);
            closeBlockTypeMenu();
            block.querySelector(".block-input")?.focus();
          } else if (e.key === "Escape") {
            closeBlockTypeMenu();
          }
        };

        const handleClickOutside = (e) => {
          const clickedMenu = menu.contains(e.target);
          const clickedBlock = block.contains(e.target);
          if (!clickedMenu && !clickedBlock) closeBlockTypeMenu();
        };

        document.addEventListener("keydown", handleKeydown);
        document.addEventListener("mousedown", handleClickOutside);

        activeMenuCleanup = () => {
          document.removeEventListener("keydown", handleKeydown);
          document.removeEventListener("mousedown", handleClickOutside);
        };
      }

      function changeBlockType(block, type) {
        block.dataset.blockType = type;
        const btn = block.querySelector(".block-type-btn");
        btn.textContent = BLOCK_TYPES[type].label;

        const editor = block.parentElement;
        const oldInput = block.querySelector(".block-input");
        const multiline = isMultilineType(type);
        const fileType = isFileType(type);

        let newInput;
        if (fileType) {
          newInput = document.createElement("input");
          newInput.type = "file";
          newInput.accept = ".pdf";
        } else if (multiline && oldInput.tagName !== "TEXTAREA") {
          newInput = document.createElement("textarea");
        } else if (!multiline && oldInput.tagName !== "INPUT") {
          newInput = document.createElement("input");
          newInput.type = "text";
        } else {
          // Same tag; just update placeholder and keep handlers
          oldInput.placeholder = `Enter ${BLOCK_TYPES[type].name.toLowerCase()}...`;
          return;
        }

        newInput.className = "block-input";
        newInput.placeholder = `Enter ${BLOCK_TYPES[type].name.toLowerCase()}...`;
        newInput.dataset.blockInput = oldInput.dataset.blockInput;

        if (!fileType) {
          newInput.value = oldInput.value || "";
          // IMPORTANT: re-attach handlers (this was the big bug)
          attachBlockInputHandlers(newInput, editor, block);
        }

        block.replaceChild(newInput, oldInput);
      }

      function getBlocksData() {
        const editor = document.getElementById("articleBlockEditor");
        const blocks = [];
        // Use creator types directly for consistency
        const typeMapping = {
          heading1: "heading1",
          heading2: "heading2",
          heading3: "heading3",
          quote: "quote",
          list: "list",
          paragraph: "paragraph",
          code: "code",
          pdf: "pdf",
        };
        editor.querySelectorAll(".block").forEach((block) => {
          const type = block.dataset.blockType;
          const input = block.querySelector(".block-input");
          if (input) {
            if (isFileType(type)) {
              if (input.files && input.files[0]) {
                blocks.push({
                  type: typeMapping[type] || type,
                  data: input.files[0].name, // Will be replaced by server filename
                });
              }
            } else if (input.value.trim()) {
              blocks.push({
                type: typeMapping[type] || type,
                data: input.value.trim(),
              });
            }
          }
        });
        return blocks;
      }

      function collectPdfFiles() {
        const pdfFiles = [];
        const editor = document.getElementById("articleBlockEditor");
        editor.querySelectorAll(".block").forEach((block) => {
          const type = block.dataset.blockType;
          if (isFileType(type)) {
            const input = block.querySelector(".block-input");
            if (input && input.files && input.files[0]) {
              pdfFiles.push(input.files[0]);
            }
          }
        });
        return pdfFiles;
      }

      // ===== CATEGORIES =====
      async function loadCategories() {
        try {
          const res = await fetch(`${API_URL}/catagories`);
          const data = await res.json();
          allCategories = Array.isArray(data) ? data : [];
          renderCategories();
        } catch (err) {
          console.error("Error loading categories:", err);
        }
      }

      function renderCategories() {
        const container = document.getElementById("categoriesList");
        container.innerHTML = allCategories
          .map(
            (cat) => `
            <div class="category-item">
              <input type="checkbox" id="cat-${cat._id}" value="${cat._id}" onchange="toggleCategory('${cat._id}')">
              <label for="cat-${cat._id}">${cat.name}</label>
            </div>
          `,
          )
          .join("");
      }

      function toggleCategory(id) {
        const checkbox = document.getElementById(`cat-${id}`);
        if (checkbox.checked) {
          if (!selectedCategories.includes(id)) selectedCategories.push(id);
        } else {
          selectedCategories = selectedCategories.filter((c) => c !== id);
        }
      }

      // ===== ARTICLES =====
      async function loadExistingArticles() {
        try {
          const res = await fetch(`${API_URL}/article`);
          const data = await res.json();
          const select = document.getElementById("articleSelect");
          select.innerHTML =
            '<option value="">-- Create New --</option>' +
            (Array.isArray(data) ? data : [])
              .map(
                (a) =>
                  `<option value="${a._id}">${a.title} (${new Date(a.date).toLocaleDateString()})</option>`,
              )
              .join("");
        } catch (err) {
          console.error("Error loading articles:", err);
        }
      }

      async function loadArticle() {
        const select = document.getElementById("articleSelect");
        const id = select.value;
        if (!id) {
          resetArticle();
          return;
        }
        try {
          const res = await fetch(`${API_URL}/article/id/${id}`);
          const article = await res.json();

          currentArticleId = article._id;
          document.getElementById("articleTitle").value = article.title || "";
          document.getElementById("articleSlug").value = article.slug || "";
          document.getElementById("articleDate").value = (
            article.date || ""
          ).split("T")[0];

          // Blocks - map old types to new types for compatibility
          const editor = document.getElementById("articleBlockEditor");
          editor.innerHTML = "";
          const typeMapping = {
            subtitle: "heading1",
            header: "heading2",
            heading1: "heading1",
            heading2: "heading2",
            heading3: "heading3",
            quote: "quote",
            list: "list",
            paragraph: "paragraph",
            code: "code",
            pdf: "pdf",
          };
          (article.elements || []).forEach((element) => {
            // Skip image elements as they're not supported in the block editor
            if (element.type === "image") return;
            const mappedType = typeMapping[element.type] || "paragraph";
            const b = addNewBlock(editor, mappedType);
            const input = b.querySelector(".block-input");
            if (mappedType === "pdf") {
              // For PDF blocks, show filename as placeholder since we can't set file input value
              input.placeholder = `Current: ${element.data || "No file selected"}`;
            } else {
              input.value = element.data || "";
            }
          });
          if (editor.children.length === 0) addNewBlock(editor, "paragraph");

          // Categories (keep your intentional spelling)
          selectedCategories = article.catagories || [];
          document.querySelectorAll('input[id^="cat-"]').forEach((cb) => {
            cb.checked = selectedCategories.includes(cb.value);
          });

          // Cover preview
          if (article.imageURI) {
            const preview = document.getElementById("coverPreview");
            preview.src = article.imageURI;
            preview.style.display = "block";
          }

          // Index checkbox
          document.getElementById("articleIndexed").checked =
            article.isIndexed ?? true;

          // Show delete button
          document.getElementById("deleteArticleBtn").style.display = "block";
        } catch (err) {
          showStatus("articleStatus", "Error loading article", "error");
        }
      }

      function setupImageUpload() {
        const input = document.getElementById("coverImage");
        input.addEventListener("change", (e) => {
          selectedCoverImage = e.target.files[0];
          if (!selectedCoverImage) return;

          const reader = new FileReader();
          reader.onload = (event) => {
            const preview = document.getElementById("coverPreview");
            preview.src = event.target.result;
            preview.style.display = "block";
          };
          reader.readAsDataURL(selectedCoverImage);

          document.getElementById("coverFileName").textContent =
            `Selected: ${selectedCoverImage.name}`;
        });
      }

      async function publishArticle() {
        const title = document.getElementById("articleTitle").value.trim();
        const slug = document.getElementById("articleSlug").value.trim();
        const date = document.getElementById("articleDate").value;
        const elements = getBlocksData();
        const pdfFiles = collectPdfFiles();

        if (
          !title ||
          !slug ||
          !date ||
          elements.length === 0 ||
          selectedCategories.length === 0
        ) {
          showStatus("articleStatus", "All fields are required", "error");
          return;
        }

        try {
          let imageURI = null;

          // Convert image to base64 if selected
          if (selectedCoverImage) {
            imageURI = await new Promise((resolve) => {
              const reader = new FileReader();
              reader.onload = (e) => resolve(e.target.result);
              reader.readAsDataURL(selectedCoverImage);
            });
          }

          // If editing and no new upload, keep existing preview src (could be URL or base64)
          const existingPreviewSrc =
            document.getElementById("coverPreview").src || null;

          const method = currentArticleId ? "PUT" : "POST";
          const endpoint = currentArticleId
            ? `article/${currentArticleId}`
            : "article/add";

          const isIndexed = document.getElementById("articleIndexed").checked;

          const formData = new FormData();
          formData.append("title", title);
          formData.append("slug", slug);
          formData.append(
            "imageURI",
            imageURI || existingPreviewSrc || "default",
          );
          formData.append("date", date);
          selectedCategories.forEach((cat) =>
            formData.append("catagories", cat),
          );
          formData.append("elements", JSON.stringify(elements));
          formData.append("isIndexed", isIndexed.toString());

          if (selectedCoverImage) {
            formData.append("imageFile", selectedCoverImage);
          }

          pdfFiles.forEach((file, index) => {
            formData.append(`pdfFiles`, file);
          });

          const res = await fetch(`${API_URL}/${endpoint}`, {
            method,
            body: formData,
          });

          if (!res.ok) throw new Error("Publish failed");

          showStatus(
            "articleStatus",
            currentArticleId ? "‚úÖ Article updated!" : "‚úÖ Article published!",
            "success",
          );

          setTimeout(() => {
            loadExistingArticles();
            resetArticle();
          }, 900);
        } catch (err) {
          showStatus("articleStatus", "Error: " + err.message, "error");
        }
      }

      function resetArticle() {
        closeBlockTypeMenu();

        document.getElementById("articleTitle").value = "";
        document.getElementById("articleSlug").value = "";
        document.getElementById("coverImage").value = "";
        document.getElementById("coverPreview").style.display = "none";
        document.getElementById("coverPreview").src = "";
        document.getElementById("coverFileName").textContent = "";
        document.getElementById("articleSelect").value = "";

        selectedCoverImage = null;
        currentArticleId = null;
        selectedCategories = [];

        document
          .querySelectorAll('input[id^="cat-"]')
          .forEach((cb) => (cb.checked = false));

        const editor = document.getElementById("articleBlockEditor");
        editor.innerHTML = "";
        addNewBlock(editor, "paragraph");

        setTodaysDate();
      }

      // ===== PAGES =====
      async function loadExistingPages() {
        try {
          const res = await fetch(`${API_URL}/pages`);
          const data = await res.json();
          const select = document.getElementById("pageSelect");
          select.innerHTML =
            '<option value="">-- Create New --</option>' +
            (Array.isArray(data) ? data : [])
              .map(
                (p) =>
                  `<option value="${p._id}">${p.title} (Order: ${p.order})</option>`,
              )
              .join("");
        } catch (err) {
          console.error("Error loading pages:", err);
        }
      }

      async function loadPage() {
        const select = document.getElementById("pageSelect");
        const id = select.value;
        if (!id) {
          resetPage();
          return;
        }
        try {
          const res = await fetch(`${API_URL}/pages/id/${id}`);
          const page = await res.json();
          currentPageId = page._id;

          document.getElementById("pageTitle").value = page.title || "";
          document.getElementById("pageSlug").value = page.slug || "";
          document.getElementById("pageOrder").value = page.order ?? 0;

          if (page.pdfFile) {
            document.querySelector('input[value="pdf"]').checked = true;
            togglePageType();
            document.getElementById("pdfFileName").textContent =
              `Current: ${page.pdfFile}`;
          } else {
            document.querySelector('input[value="text"]').checked = true;
            togglePageType();
            if (page.elements && Array.isArray(page.elements)) {
              document.getElementById("pageContent").value = page.elements
                .map((e) => e.data || "")
                .join("\n\n");
            } else {
              document.getElementById("pageContent").value = "";
            }
          }

          // Show delete button
          document.getElementById("deletePageBtn").style.display = "block";
        } catch (err) {
          showStatus("pageStatus", "Error loading page", "error");
        }
      }

      function togglePageType() {
        const isText =
          document.querySelector('input[name="pageType"]:checked').value ===
          "text";
        document.getElementById("textPageFields").style.display = isText
          ? "block"
          : "none";
        document.getElementById("pdfPageFields").style.display = isText
          ? "none"
          : "block";
      }

      function setupPdfUpload() {
        const input = document.getElementById("pdfFile");
        input.addEventListener("change", (e) => {
          selectedPdfFile = e.target.files[0];
          document.getElementById("pdfFileName").textContent = selectedPdfFile
            ? `Selected: ${selectedPdfFile.name}`
            : "";
        });
      }

      async function publishPage() {
        const title = document.getElementById("pageTitle").value.trim();
        const slug = document.getElementById("pageSlug").value.trim();
        const order =
          parseInt(document.getElementById("pageOrder").value, 10) || 0;
        const isText =
          document.querySelector('input[name="pageType"]:checked').value ===
          "text";

        if (!title || !slug) {
          showStatus("pageStatus", "Title and slug are required", "error");
          return;
        }

        try {
          if (isText) {
            const content = document.getElementById("pageContent").value.trim();
            if (!content) {
              showStatus("pageStatus", "Content is required", "error");
              return;
            }

            const elements = content
              .split(/\n\s*\n/)
              .filter((p) => p.trim())
              .map((p) => ({ type: "paragraph", data: p.trim() }));

            const method = currentPageId ? "PUT" : "POST";
            const endpoint = currentPageId
              ? `pages/${currentPageId}`
              : "pages/add";

            const res = await fetch(`${API_URL}/${endpoint}`, {
              method,
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title, slug, order, elements }),
            });

            if (!res.ok) throw new Error("Publish failed");
            showStatus(
              "pageStatus",
              currentPageId ? "‚úÖ Page updated!" : "‚úÖ Page created!",
              "success",
            );
          } else {
            if (!selectedPdfFile && !currentPageId) {
              showStatus("pageStatus", "PDF file is required", "error");
              return;
            }

            const formData = new FormData();
            formData.append("title", title);
            formData.append("slug", slug);
            formData.append("order", order);
            if (selectedPdfFile) formData.append("pdfFile", selectedPdfFile);

            const method = currentPageId ? "PUT" : "POST";
            const endpoint = currentPageId
              ? `pages/${currentPageId}`
              : "pages/add";

            const res = await fetch(`${API_URL}/${endpoint}`, {
              method,
              body: formData,
            });

            if (!res.ok) throw new Error("Publish failed");
            showStatus(
              "pageStatus",
              currentPageId ? "‚úÖ Page updated!" : "‚úÖ Page created!",
              "success",
            );
          }

          setTimeout(() => {
            loadExistingPages();
            resetPage();
          }, 900);
        } catch (err) {
          showStatus("pageStatus", "Error: " + err.message, "error");
        }
      }

      function resetPage() {
        document.getElementById("pageTitle").value = "";
        document.getElementById("pageSlug").value = "";
        document.getElementById("pageOrder").value = "0";
        document.getElementById("pageContent").value = "";
        document.getElementById("pdfFile").value = "";
        document.getElementById("pdfFileName").textContent = "";
        document.getElementById("pageSelect").value = "";
        document.querySelector('input[value="text"]').checked = true;
        togglePageType();
        selectedPdfFile = null;
        currentPageId = null;
      }

      async function deleteArticle() {
        if (!currentArticleId) return;
        if (!confirm("Are you sure you want to delete this article?")) return;

        try {
          const res = await fetch(`${API_URL}/article/${currentArticleId}`, {
            method: "DELETE",
          });
          if (!res.ok) throw new Error("Delete failed");

          showStatus("articleStatus", "‚úÖ Article deleted!", "success");
          setTimeout(() => {
            loadExistingArticles();
            resetArticle();
          }, 900);
        } catch (err) {
          showStatus("articleStatus", "Error: " + err.message, "error");
        }
      }

      async function deletePage() {
        if (!currentPageId) return;
        if (!confirm("Are you sure you want to delete this page?")) return;

        try {
          const res = await fetch(`${API_URL}/pages/${currentPageId}`, {
            method: "DELETE",
          });
          if (!res.ok) throw new Error("Delete failed");

          showStatus("pageStatus", "‚úÖ Page deleted!", "success");
          setTimeout(() => {
            loadExistingPages();
            resetPage();
          }, 900);
        } catch (err) {
          showStatus("pageStatus", "Error: " + err.message, "error");
        }
      }

      function setTodaysDate() {
        const today = new Date().toISOString().split("T")[0];
        document.getElementById("articleDate").value = today;
      }

      function setupAutoPopulate() {
        // Auto-populate page fields when slug changes (only for new pages)
        document
          .getElementById("pageSlug")
          .addEventListener("input", async (e) => {
            const slug = e.target.value.trim();
            // Only auto-populate if we're creating a new page (no currentPageId)
            // and the select dropdown is set to "-- Create New --"
            if (
              !slug ||
              currentPageId ||
              document.getElementById("pageSelect").value !== ""
            )
              return;

            try {
              const res = await fetch(`${API_URL}/pages`);
              const pages = await res.json();
              const existingPage = pages.find((p) => p.slug === slug);
              if (existingPage) {
                currentPageId = existingPage._id;
                document.getElementById("pageTitle").value =
                  existingPage.title || "";
                document.getElementById("pageOrder").value =
                  existingPage.order ?? 0;

                if (existingPage.pdfFile) {
                  document.querySelector('input[value="pdf"]').checked = true;
                  togglePageType();
                  document.getElementById("pdfFileName").textContent =
                    `Current: ${existingPage.pdfFile}`;
                } else {
                  document.querySelector('input[value="text"]').checked = true;
                  togglePageType();
                  if (
                    existingPage.elements &&
                    Array.isArray(existingPage.elements)
                  ) {
                    document.getElementById("pageContent").value =
                      existingPage.elements
                        .map((e) => e.data || "")
                        .join("\n\n");
                  } else {
                    document.getElementById("pageContent").value = "";
                  }
                }
              }
            } catch (err) {
              console.error("Error checking existing pages:", err);
            }
          });
      }
    </script>
  </body>
</html>
